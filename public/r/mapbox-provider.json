{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "mapbox-provider",
  "title": "Mapbox Provider",
  "description": "Fetches location suggestions from Mapbox Geocoding API. Requires a Mapbox API key. Returns results with coordinates, place name, and full API response.",
  "files": [
    {
      "path": "src/lib/autocomplete/providers/mapbox.ts",
      "content": "import type { LocationSuggestion } from \"@/components/ui/location-autocomplete\";\nimport { buildQueryString, fetcher } from \"@/lib/autocomplete/api\";\n\nconst BASE_URL = \"https://api.mapbox.com/search/searchbox/v1/suggest\";\n\n/**\n * Query options for the Mapbox Geocoding API (Autocomplete / Forward Geocoding).\n */\nexport interface MapboxQueryOptions {\n  /**\n   * ISO language code for the results. Defaults to English if not provided.\n   * Example: \"en\"\n   */\n  language?: string;\n\n  /**\n   * Maximum number of results to return. Up to 10.\n   * Default: 10\n   */\n  limit?: number;\n\n  /**\n   * Bias results to favor locations closer to a specific point.\n   * Provide either \"ip\" to use the user's IP location,\n   * or two comma-separated coordinates in longitude,latitude order.\n   * Example: \"13.388860,52.517037\"\n   */\n  proximity?: string;\n\n  /**\n   * Restrict results to a bounding box.\n   * Four comma-separated numbers: minLongitude,minLatitude,maxLongitude,maxLatitude\n   * Example: \"13.08836,52.33812,13.761,52.6755\"\n   * Note: The bounding box cannot cross the 180th meridian.\n   */\n  bbox?: string;\n\n  /**\n   * Restrict results to specific countries.\n   * Comma-separated list of ISO 3166-1 alpha-2 country codes.\n   * Example: \"US,CA,GB\"\n   */\n  country?: string;\n\n  /**\n   * Limit results to specific types of features.\n   * Comma-separated list.\n   * Available types: country, region, postcode, district, place, city, locality,\n   * neighborhood, street, address, poi, category\n   * Example: \"city,postcode\"\n   */\n  types?: string;\n\n  /**\n   * Limit results to specific POI categories.\n   * Comma-separated list of canonical category names.\n   * Example: \"restaurant,bank\"\n   */\n  poi_category?: string;\n\n  /**\n   * Exclude specific POI categories from results.\n   * Comma-separated list of canonical category names.\n   * Example: \"atm,parking\"\n   */\n  poi_category_exclusions?: string;\n\n  /**\n   * Enable Estimate Time Arrival (ETA) calculation.\n   * Only allowed value is \"navigation\".\n   * Requires `navigationProfile` and either `origin` or `proximity` to be provided.\n   */\n  eta_type?: \"navigation\";\n\n  /**\n   * Navigation routing profile for ETA calculation.\n   * Available profiles: driving, walking, cycling\n   * Required if `etaType` is enabled.\n   */\n  navigation_profile?: \"driving\" | \"walking\" | \"cycling\";\n\n  /**\n   * Origin location for ETA calculation.\n   * Coordinates in longitude,latitude order.\n   * When both `proximity` and `origin` are provided, `origin` is the route target,\n   * while `proximity` indicates the current user location.\n   * Example: \"13.388860,52.517037\"\n   */\n  origin?: string;\n\n  /**\n   * Customer-provided session token to group multiple requests together for billing.\n   * UUIDv4 recommended.\n   * Example: \"550e8400-e29b-41d4-a716-446655440000\"\n   */\n  session_token?: string;\n}\n\nexport interface MapboxResponse {\n  suggestions: MapboxSuggestion[];\n  attribution?: string;\n  response_id?: string;\n}\n\nexport interface MapboxSuggestion {\n  name: string;\n  mapbox_id: string;\n  feature_type?: string;\n  address?: string;\n  full_address?: string;\n  place_formatted?: string;\n  context?: MapboxContext;\n  language?: string;\n  maki?: string;\n  poi_category?: string[];\n  poi_category_ids?: string[];\n  external_ids?: Record<string, string>;\n  metadata?: Record<string, unknown>;\n  distance?: number;\n}\n\nexport interface MapboxContext {\n  country?: CountryContext;\n  region?: RegionContext;\n  postcode?: IdNameContext;\n  place?: IdNameContext;\n  neighborhood?: IdNameContext;\n  address?: AddressContext;\n  street?: { name?: string };\n}\n\nexport interface CountryContext {\n  name?: string;\n  country_code?: string; // e.g. \"US\"\n  country_code_alpha_3?: string; // e.g. \"USA\"\n}\n\nexport interface RegionContext {\n  name?: string;\n  region_code?: string; // e.g. \"MI\"\n  region_code_full?: string; // e.g. \"US-MI\"\n}\n\nexport interface IdNameContext {\n  id?: string;\n  name?: string;\n}\n\nexport interface AddressContext {\n  name?: string;\n  address_number?: string;\n  street_name?: string;\n}\n\nexport const normalizeMapboxResult = <T extends MapboxSuggestion>(\n  item: T,\n): LocationSuggestion<T> => ({\n  place_id: item.mapbox_id || Math.random().toString(),\n  display_name: item.place_formatted || item.address || \"Unknown location\",\n  lat: \"0\",\n  lon: \"0\",\n  type: item.feature_type || \"unknown\",\n  importance: 0.5,\n  raw: item,\n});\n\nexport async function fetchMapboxSuggestions(\n  query: string,\n  config: { apiKey: string; baseUrl?: string },\n  options?: MapboxQueryOptions,\n): Promise<LocationSuggestion<MapboxSuggestion>[]> {\n  const apiKey = config.apiKey;\n  if (!apiKey) {\n    throw new Error(\"Mapbox requires an API key in config.apiKey\");\n  }\n\n  const params = buildQueryString({\n    ...(options || {}),\n    access_token: config.apiKey,\n    limit: options?.limit || 10,\n    q: query,\n    session_token: 3,\n  });\n\n  const url = `${config.baseUrl || BASE_URL}?${params}`;\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  return fetcher<MapboxResponse>(url, {\n    headers,\n  }).then(({ response }) => response.suggestions.map(normalizeMapboxResult));\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/autocomplete/api.ts",
      "content": "export interface Response<T> {\n  response: T;\n  status: number;\n}\n\nexport const buildQueryString = (\n  params: Record<\n    string,\n    string | number | boolean | undefined | null | number[]\n  >,\n): string => {\n  return Object.entries(params)\n    .filter(\n      ([_, value]) => value !== undefined && value !== null && value !== \"\",\n    ) // skip empty\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`,\n    )\n    .join(\"&\");\n};\n\nexport async function fetcher<T>(\n  url: string,\n  options: RequestInit = {},\n): Promise<Response<T>> {\n  const res = await fetch(url, options);\n  const response = await res.json();\n\n  return {\n    response: response as T,\n    status: res.status,\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}