{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "opencage-provider",
  "title": "OpenCage Provider",
  "description": "Fetches location suggestions from OpenCage Geocoder API. Requires an OpenCage API key. Returns geocoding results with formatted address, coordinates, and components.",
  "files": [
    {
      "path": "src/lib/autocomplete/providers/opencage.ts",
      "content": "import type {\n  LocationSuggestion,\n  ProviderConfig,\n} from \"@/components/ui/location-autocomplete\";\nimport { buildQueryString, fetcher } from \"@/lib/autocomplete/api\";\n\nconst BASE_URL = \"https://api.opencagedata.com/geosearch\";\n\n/**\n * Query options for the OpenCage Geocoding / Autocomplete API.\n */\nexport interface OpenCageQueryOptions {\n  /**\n   * Restrict results to a bounding box.\n   * Provide two coordinate points forming the south-west and north-east corners:\n   * minLongitude, minLatitude, maxLongitude, maxLatitude\n   * Example: \"-0.563160,51.280430,0.278970,51.683979\"\n   */\n  bounds?: string;\n\n  /**\n   * Restrict results to a specific country/territory.\n   * Two-letter ISO 3166-1 Alpha 2 code (lowercase).\n   * Example: \"gb\", \"fr\", \"us\"\n   */\n  countrycode?: string;\n\n  /**\n   * Language to display results in.\n   * Two-letter code (de, en, es, fr) or \"native\" for local language.\n   * Defaults to \"en\".\n   */\n  language?: \"de\" | \"en\" | \"es\" | \"fr\" | \"native\";\n\n  /**\n   * Maximum number of results to display.\n   * Default: 5. Maximum: 10\n   */\n  limit?: number;\n\n  /**\n   * Label to display when the API returns no results (for i18n).\n   * Default: \"No results.\"\n   */\n  noResults?: string;\n}\n\nexport interface OpenCageResponse {\n  documentation?: string;\n  licenses?: OpenCageLicense[];\n  results: OpenCageResult[];\n  status?: OpenCageStatus;\n  stay_informed?: OpenCageStayInformed;\n  thanks?: string;\n  timestamp?: OpenCageTimestamp;\n  total_results?: number;\n}\n\nexport interface OpenCageLicense {\n  name?: string;\n  url?: string;\n}\n\nexport interface OpenCageResult {\n  formatted: string;\n  geometry: OpenCageGeometry;\n  name?: string;\n  bounds?: OpenCageBounds;\n  components?: Record<string, unknown>;\n  annotations?: Record<string, unknown>;\n}\n\nexport interface OpenCageGeometry {\n  lat: string;\n  lng: string;\n}\n\nexport interface OpenCageBounds {\n  northeast: OpenCageGeometry;\n  southwest: OpenCageGeometry;\n}\n\nexport interface OpenCageStatus {\n  code?: number;\n  message?: string;\n}\n\nexport interface OpenCageStayInformed {\n  blog?: string;\n  mastodon?: string;\n}\n\nexport interface OpenCageTimestamp {\n  created_http?: string;\n  created_unix?: number;\n}\n\nexport const normalizeOpenCageResult = <T extends OpenCageResult>(\n  item: T,\n): LocationSuggestion<T> => ({\n  place_id: Math.random().toString(),\n  display_name: item.formatted || \"Unknown location\",\n  lat: item.geometry?.lat?.toString() || \"0\",\n  lon: item.geometry?.lng?.toString() || \"0\",\n  type: \"location\",\n  importance: 0.5,\n  raw: item,\n});\n\nexport async function fetchOpenCageSuggestions(\n  query: string,\n  config: ProviderConfig,\n  options?: OpenCageQueryOptions,\n): Promise<LocationSuggestion<OpenCageResult>[]> {\n  const apiKey = config.apiKey;\n  if (!apiKey) {\n    throw new Error(\n      \"OpenCage Geocoding API requires an API key in config.apiKey\",\n    );\n  }\n\n  const params = buildQueryString({\n    ...(options || {}),\n    q: query,\n    key: config.apiKey,\n    limit: options?.limit || 10,\n    language: \"en\",\n  });\n\n  const url = `${config.baseUrl || BASE_URL}?${params}`;\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  return fetcher<OpenCageResponse>(url, {\n    headers,\n  }).then(({ response }) => response.results.map(normalizeOpenCageResult));\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/autocomplete/api.ts",
      "content": "export interface Response<T> {\n  response: T;\n  status: number;\n}\n\nexport const buildQueryString = (\n  params: Record<\n    string,\n    string | number | boolean | undefined | null | number[]\n  >,\n): string => {\n  return Object.entries(params)\n    .filter(\n      ([_, value]) => value !== undefined && value !== null && value !== \"\",\n    ) // skip empty\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`,\n    )\n    .join(\"&\");\n};\n\nexport async function fetcher<T>(\n  url: string,\n  options: RequestInit = {},\n): Promise<Response<T>> {\n  const res = await fetch(url, options);\n  const response = await res.json();\n\n  return {\n    response: response as T,\n    status: res.status,\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}