{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "google-provider",
  "title": "Google Maps Provider",
  "description": "Fetches place autocomplete suggestions using Google Places API. Requires a Google API key. Returns structured place information including formatted address and place ID.",
  "files": [
    {
      "path": "src/lib/autocomplete/providers/google.ts",
      "content": "import type {\n  LocationSuggestion,\n  ProviderConfig,\n} from \"@/components/ui/location-autocomplete\";\nimport { fetcher } from \"@/lib/autocomplete/api\";\n\nconst BASE_URL = \"https://places.googleapis.com/v1/places:autocomplete\";\n\n/**\n * Options for the Google Places Autocomplete API.\n */\nexport interface GoogleQueryOptions {\n  /**\n   * Comma-separated list specifying which fields to return in the response.\n   * Optional.\n   * Example: \"name,geometry,formatted_address\"\n   */\n  fieldMask?: string;\n\n  /**\n   * Restricts results to places matching one of up to five specified primary types.\n   * Optional.\n   * Example: [\"restaurant\", \"cafe\"]\n   */\n  includedPrimaryTypes?: string[];\n\n  /**\n   * If true, includes businesses without a physical location (service area businesses).\n   * Defaults to false.\n   */\n  includePureServiceAreaBusinesses?: boolean;\n\n  /**\n   * If true, includes both place and query predictions in the response.\n   * Defaults to false.\n   */\n  includeQueryPredictions?: boolean;\n\n  /**\n   * Array of up to 15 two-character country codes to restrict results to.\n   * Optional.\n   * Example: [\"US\", \"CA\"]\n   */\n  includedRegionCodes?: string[];\n\n  /**\n   * Zero-based Unicode character offset of the cursor position within the input string.\n   * Influences predictions. Defaults to the length of the input.\n   */\n  inputOffset?: number;\n\n  /**\n   * Biases search results toward a specific location.\n   * Cannot be used together with `locationRestriction`.\n   */\n  locationBias?: {\n    /** Circle area bias */\n    circle?: {\n      center: { lat: number; lng: number };\n      radius: number; // in meters\n    };\n    /** Rectangle area bias */\n    rectangle?: {\n      low: { lat: number; lng: number };\n      high: { lat: number; lng: number };\n    };\n  };\n\n  /**\n   * Restricts search results within a specific area.\n   * Cannot be used together with `locationBias`.\n   */\n  locationRestriction?: {\n    circle?: {\n      center: { lat: number; lng: number };\n      radius: number; // in meters\n    };\n    rectangle?: {\n      low: { lat: number; lng: number };\n      high: { lat: number; lng: number };\n    };\n  };\n\n  /**\n   * Origin point used to calculate straight-line distance to predicted destinations.\n   * Optional.\n   */\n  origin?: { lat: number; lng: number };\n\n  /**\n   * User-generated string to group Autocomplete calls into a session for billing purposes.\n   * Optional.\n   */\n  sessionToken?: string;\n\n  /**\n   * Preferred language for the response, as BCP-47 codes.\n   * Optional.\n   * Example: \"en\"\n   */\n  languageCode?: string;\n}\n\n// Google Places Autocomplete API types\nexport interface GooglePlacesAutocompleteResponse {\n  suggestions: GooglePlaceSuggestion[];\n}\n\nexport interface GooglePlaceSuggestion {\n  placePrediction: GooglePlacePrediction;\n}\n\nexport interface GooglePlacePrediction {\n  place?: string; // e.g., \"places/ChIJ...\"\n  placeId?: string; // e.g., \"ChIJ...\"\n  text?: GooglePredictionText; // full display text\n  structuredFormat?: GooglePredictionStructuredFormat; // main/secondary split\n  types?: string[]; // e.g., ['geocode', 'street_address']\n}\n\nexport interface GooglePredictionText {\n  text: string;\n  matches?: GooglePredictionTextMatch[];\n}\n\nexport interface GooglePredictionStructuredFormat {\n  mainText: GooglePredictionText;\n  secondaryText?: GooglePredictionText;\n}\n\nexport interface GooglePredictionTextMatch {\n  startOffset?: number;\n  endOffset: number;\n}\n\nexport const normalizeGoogleResult = <T extends GooglePlaceSuggestion>(\n  item: T,\n): LocationSuggestion<T> => {\n  return {\n    place_id: item.placePrediction.placeId || Math.random().toString(),\n    display_name:\n      item.placePrediction.text?.text ||\n      item.placePrediction.structuredFormat?.mainText?.text ||\n      \"Unknown location\",\n    lat: \"0\",\n    lon: \"0\",\n    type: (item.placePrediction.types ?? []).join(\",\") || \"unknown\",\n    importance: 0.5,\n    raw: item,\n  };\n};\n\nexport async function fetchGoogleSuggestions(\n  query: string,\n  config: ProviderConfig,\n  options?: GoogleQueryOptions,\n): Promise<LocationSuggestion<GooglePlaceSuggestion>[]> {\n  const apiKey = config.apiKey;\n  if (!apiKey) {\n    throw new Error(\"Google Places API requires an API key in config.apiKey\");\n  }\n\n  const { fieldMask } = options || {};\n  const params = {\n    input: query,\n    ...(options || {}),\n  };\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  headers[\"X-Goog-Api-Key\"] = apiKey;\n  if (fieldMask) {\n    headers[\"X-Goog-FieldMask\"] = fieldMask;\n  }\n\n  const url = config.baseUrl || BASE_URL;\n\n  return fetcher<GooglePlacesAutocompleteResponse>(url, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(params),\n  }).then(({ response }) => response.suggestions.map(normalizeGoogleResult));\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/autocomplete/api.ts",
      "content": "export interface Response<T> {\n  response: T;\n  status: number;\n}\n\nexport const buildQueryString = (\n  params: Record<\n    string,\n    string | number | boolean | undefined | null | number[]\n  >,\n): string => {\n  return Object.entries(params)\n    .filter(\n      ([_, value]) => value !== undefined && value !== null && value !== \"\",\n    ) // skip empty\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`,\n    )\n    .join(\"&\");\n};\n\nexport async function fetcher<T>(\n  url: string,\n  options: RequestInit = {},\n): Promise<Response<T>> {\n  const res = await fetch(url, options);\n  const response = await res.json();\n\n  return {\n    response: response as T,\n    status: res.status,\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}