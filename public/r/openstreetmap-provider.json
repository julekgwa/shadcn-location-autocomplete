{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "openstreetmap-provider",
  "title": "OpenStreetMap Provider",
  "description": "Fetches place suggestions from OpenStreetMap Nominatim API. Returns results with display name, place ID, and raw API data. No API key is required.",
  "files": [
    {
      "path": "src/lib/autocomplete/providers/openstreetmap.ts",
      "content": "import type {\n  LocationSuggestion,\n  ProviderConfig,\n} from \"@/components/ui/location-autocomplete\";\nimport { buildQueryString, fetcher } from \"@/lib/autocomplete/api\";\n\nconst BASE_URL = \"https://nominatim.openstreetmap.org/search\";\n\nexport interface OpenStreetMapQueryOptions {\n  /**\n   * Maximum number of results to return.\n   * Default: 10\n   */\n  limit?: number;\n\n  /**\n   * Return results in GeoJSON polygon format.\n   * Default: false\n   */\n  polygon_geojson?: boolean;\n\n  /**\n   * Apply a bounding box restriction to results.\n   * Should be provided as: [left, top, right, bottom]\n   */\n  viewbox?: [number, number, number, number];\n\n  /**\n   * Restrict results to the viewbox area.\n   * Default: false\n   */\n  bounded?: boolean;\n\n  /**\n   * Preferred language for the results.\n   * Example: \"en\"\n   */\n  \"accept-language\"?: string;\n\n  /**\n   * Limit results to specific country codes (ISO 3166-1 alpha2).\n   * Example: \"de,gb\"\n   */\n  countrycodes?: string;\n\n  /**\n   * Restrict results to a specific layer.\n   * Example: \"address,poi,railway\"\n   */\n  layer?: string;\n\n  /**\n   * Polygon simplification threshold.\n   * Example: 0.003\n   */\n  polygon_threshold?: number;\n\n  /**\n   * Result offset within the full result set.\n   * Default: 0\n   */\n  offset?: number;\n\n  /**\n   * Format of the response.\n   * Default: \"json\"\n   * Possible values: \"json\", \"xml\", \"jsonv2\", \"geojson\", \"geocodejson\"\n   */\n  format?: \"json\" | \"xml\" | \"jsonv2\" | \"geojson\" | \"geocodejson\";\n}\n\n// OpenStreetMap (Nominatim) Search API\nexport type OpenStreetMapResponse = OpenStreetMapResult[];\n\nexport interface OpenStreetMapResult {\n  place_id: number | string;\n  licence?: string;\n  osm_type?: \"node\" | \"way\" | \"relation\" | string;\n  osm_id?: number | string;\n  lat: string;\n  lon: string;\n  class?: string;\n  type?: string;\n  place_rank?: number;\n  importance?: number;\n  addresstype?: string;\n  name?: string;\n  display_name: string;\n  address?: OpenStreetMapAddress;\n  boundingbox?: [string, string, string, string];\n}\n\nexport interface OpenStreetMapAddress {\n  road?: string;\n  suburb?: string;\n  city?: string;\n  county?: string;\n  state?: string;\n  \"ISO3166-2-lvl4\"?: string;\n  postcode?: string;\n  country?: string;\n  country_code?: string;\n}\n\nexport const normalizeOpenStreetMapResult = <T extends OpenStreetMapResult>(\n  item: T,\n): LocationSuggestion<T> => ({\n  place_id:\n    item.place_id?.toString() ||\n    item.osm_id?.toString() ||\n    Math.random().toString(),\n  display_name: item.display_name || item.name || \"Unknown location\",\n  lat: item.lat || \"0\",\n  lon: item.lon || \"0\",\n  type: item.type || item.class || \"unknown\",\n  importance: item.importance || 0.5,\n  raw: item,\n});\n\nexport async function fetchOpenStreetMapSuggestions(\n  query: string,\n  config?: ProviderConfig,\n  options?: OpenStreetMapQueryOptions,\n): Promise<LocationSuggestion<OpenStreetMapResult>[]> {\n  const params = buildQueryString({\n    ...(options || {}),\n    q: query,\n    format: options?.format || \"jsonv2\",\n    limit: options?.limit || 10,\n    addressdetails: 1,\n  });\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const endpoint = `${config?.baseUrl || BASE_URL}?${params}`;\n  return fetcher<OpenStreetMapResponse>(endpoint, {\n    headers,\n  }).then(({ response }) => response.map(normalizeOpenStreetMapResult));\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/autocomplete/api.ts",
      "content": "export interface Response<T> {\n  response: T;\n  status: number;\n}\n\nexport const buildQueryString = (\n  params: Record<\n    string,\n    string | number | boolean | undefined | null | number[]\n  >,\n): string => {\n  return Object.entries(params)\n    .filter(\n      ([_, value]) => value !== undefined && value !== null && value !== \"\",\n    ) // skip empty\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`,\n    )\n    .join(\"&\");\n};\n\nexport async function fetcher<T>(\n  url: string,\n  options: RequestInit = {},\n): Promise<Response<T>> {\n  const res = await fetch(url, options);\n  const response = await res.json();\n\n  return {\n    response: response as T,\n    status: res.status,\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}