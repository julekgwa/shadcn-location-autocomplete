{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tomtom-provider",
  "title": "TomTom Provider",
  "description": "Fetches location suggestions from TomTom Search API. Requires a TomTom API key. Returns results with full address, position coordinates, and bounding box.",
  "files": [
    {
      "path": "src/lib/autocomplete/providers/tomtom.ts",
      "content": "import type {\n  LocationSuggestion,\n  ProviderConfig,\n} from \"@/components/ui/location-autocomplete\";\nimport { buildQueryString, fetcher } from \"@/lib/autocomplete/api\";\n\n/**\n * TomTom Search / Autocomplete API query options\n */\nexport interface TomTomQueryOptions {\n  /**\n   * Base URL for calling the API.\n   * Example: \"api.tomtom.com\" or \"kr-api.tomtom.com\"\n   */\n  baseURL?: string;\n\n  /**\n   * Service version.\n   * Example: \"2\"\n   */\n  versionNumber?: string;\n\n  /**\n   * Response format.\n   * Allowed values: \"json\", \"jsonp\", \"js\", \"xml\"\n   */\n  ext?: \"json\" | \"jsonp\" | \"js\" | \"xml\";\n\n  /**\n   * API Key valid for the requested service\n   */\n  key?: string;\n\n  /**\n   * The query string. Must be URL-encoded.\n   * Can include coordinates or mapcodes directly.\n   * Example: \"Berlin Pariser 20\"\n   */\n  query?: string;\n\n  /**\n   * Enable predictive mode for partial input.\n   * Default: false\n   */\n  typeahead?: boolean;\n\n  /**\n   * Maximum number of responses.\n   * Default: 10, Max: 100\n   */\n  limit?: number;\n\n  /**\n   * Result offset within the full result set.\n   * Default: 0\n   */\n  ofs?: number;\n\n  /**\n   * Comma-separated ISO 3166-1 alpha-2 or alpha-3 country codes to limit search.\n   * Example: \"FR,ES\" or \"FRA,ESP\"\n   */\n  countrySet?: string;\n\n  /**\n   * Location bias: \"point:lat,lon\" or \"rectangle:topLeftLat,topLeftLon,btmRightLat,btmRightLon\".\n   * Point takes precedence over bounding box.\n   */\n  geoBias?: string;\n\n  /** Latitude for point-radius bias */\n  lat?: number;\n\n  /** Longitude for point-radius bias */\n  lon?: number;\n\n  /** Radius in meters for filtering around lat/lon */\n  radius?: number;\n\n  /** Bounding box top-left coordinates as \"lat,lon\" */\n  topLeft?: string;\n\n  /** Bounding box bottom-right coordinates as \"lat,lon\" */\n  btmRight?: string;\n\n  /** Language in which search results should be returned (IETF language tag) */\n  language?: string;\n\n  /** Comma-separated indexes for which extended postal codes should be included. Example: \"POI,PAD\" */\n  extendedPostalCodesFor?: string;\n\n  /** Minimum fuzziness level (1–4). Default: 1 */\n  minFuzzyLevel?: number;\n\n  /** Maximum fuzziness level (1–4). Default: 2 */\n  maxFuzzyLevel?: number;\n\n  /** Comma-separated list of indexes to be used for search. Example: \"POI,PAD,Str\" */\n  idxSet?: string;\n\n  /** Comma-separated list of POI category identifiers. Example: \"7315,7315017\" */\n  categorySet?: string;\n\n  /** Comma-separated list of brand names. Example: \"TomTom,Foobar\" */\n  brandSet?: string;\n\n  /** Comma-separated list of connector types (for EV stations). Example: \"IEC62196Type2CableAttached\" */\n  connectorSet?: string;\n\n  /** Minimum power (kW) for EV stations. Example: 22.2 */\n  minPowerKW?: number;\n\n  /** Maximum power (kW) for EV stations. Example: 43.2 */\n  maxPowerKW?: number;\n\n  /** Comma-separated list of fuel types. Example: \"Diesel,Petrol\" */\n  fuelSet?: string;\n\n  /** Comma-separated list of vehicle types. Example: \"Car,Truck\" */\n  vehicleTypeSet?: string;\n\n  /** Geopolitical view context. Default: \"Unified\" or country-specific. Example: \"AR, CN, IN\" */\n  view?: string;\n\n  /** POI opening hours mode. Example: \"nextSevenDays\" */\n  openingHours?: string;\n\n  /** Timezone mode. Example: \"iana\" */\n  timeZone?: string;\n\n  /** Comma-separated list of mapcodes to return. Example: \"Local,Alternative\" */\n  mapcodes?: string;\n\n  /** Related POIs to include: \"off\", \"child\", \"parent\", \"all\" */\n  relatedPois?: \"off\" | \"child\" | \"parent\" | \"all\";\n\n  /** Comma-separated list of entity types for filtering. Example: \"Municipality,Neighbourhood\" */\n  entityTypeSet?: string;\n}\n\n// TomTom Search API types\nexport interface TomTomAutocompleteResponse {\n  summary: {\n    query: string;\n    queryType: string;\n    queryTime: number;\n    numResults: number;\n    offset: number;\n    totalResults: number;\n    fuzzyLevel: number;\n    queryIntent: unknown[];\n  };\n  results: TomTomResult[];\n}\n\nexport interface TomTomResult {\n  type: string; // e.g., \"Geography\", \"POI\", \"Street\"\n  id: string;\n  score: number;\n  entityType?: string;\n  info?: string;\n  poi?: TomTomPOI;\n  address: TomTomAddress;\n  position: TomTomPosition;\n  viewport?: TomTomViewport;\n  boundingBox?: TomTomBoundingBox;\n  entryPoints?: TomTomEntryPoint[];\n  dataSources?: {\n    geometry?: {\n      id: string;\n    };\n  };\n}\n\nexport interface TomTomPOI {\n  name: string;\n  categorySet?: { id: number }[];\n  categories?: string[];\n  classifications?: {\n    code: string;\n    names: {\n      nameLocale: string;\n      name: string;\n    }[];\n  }[];\n}\n\nexport interface TomTomAddress {\n  streetNumber?: string;\n  streetName?: string;\n  municipality?: string;\n  municipalitySubdivision?: string;\n  neighbourhood?: string;\n  countrySecondarySubdivision?: string;\n  countrySubdivision?: string;\n  countrySubdivisionName?: string;\n  countrySubdivisionCode?: string;\n  postalCode?: string;\n  extendedPostalCode?: string;\n  countryCode: string;\n  country: string;\n  countryCodeISO3: string;\n  freeformAddress: string;\n  localName?: string;\n}\n\nexport interface TomTomPosition {\n  lat: number;\n  lon: number;\n}\n\nexport interface TomTomViewport {\n  topLeftPoint: TomTomPosition;\n  btmRightPoint: TomTomPosition;\n}\n\nexport interface TomTomBoundingBox {\n  topLeftPoint: TomTomPosition;\n  btmRightPoint: TomTomPosition;\n}\n\nexport interface TomTomEntryPoint {\n  type: string; // e.g., \"main\"\n  position: TomTomPosition;\n}\n\nexport const normalizeTomTomResult = <T extends TomTomResult>(\n  item: T,\n): LocationSuggestion<T> => ({\n  place_id: item.id || Math.random().toString(),\n  display_name:\n    item.poi?.name ||\n    item.address?.freeformAddress ||\n    item.address?.streetName ||\n    \"Unknown location\",\n  lat: item.position?.lat?.toString() || \"0\",\n  lon: item.position?.lon?.toString() || \"0\",\n  type: item.type || item.poi?.categories?.[0] || item.entityType || \"unknown\",\n  importance: item.score ? item.score / 3 : 0.5, // Normalize TomTom's score to 0-1 range\n  raw: item,\n});\n\nexport async function fetchTomTomSuggestions(\n  query: string,\n  config?: ProviderConfig,\n  options?: TomTomQueryOptions,\n): Promise<LocationSuggestion<TomTomResult>[]> {\n  const apiKey = config?.apiKey;\n  if (!apiKey) {\n    throw new Error(\"TomTom API key is required in the provider config.\");\n  }\n\n  const params = buildQueryString({\n    ...(options || {}),\n    key: apiKey,\n    typeahead: true,\n    limit: options?.limit,\n  });\n\n  const ext = options?.ext || \"json\";\n  const version = options?.versionNumber || 2;\n\n  const url = `${\n    config.baseUrl || `https://api.tomtom.com/search/${version}/search`\n  }/${encodeURIComponent(query)}.${ext}?${params}`;\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  return fetcher<TomTomAutocompleteResponse>(url, {\n    headers,\n  }).then(({ response }) => response.results.map(normalizeTomTomResult));\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/autocomplete/api.ts",
      "content": "export interface Response<T> {\n  response: T;\n  status: number;\n}\n\nexport const buildQueryString = (\n  params: Record<\n    string,\n    string | number | boolean | undefined | null | number[]\n  >,\n): string => {\n  return Object.entries(params)\n    .filter(\n      ([_, value]) => value !== undefined && value !== null && value !== \"\",\n    ) // skip empty\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`,\n    )\n    .join(\"&\");\n};\n\nexport async function fetcher<T>(\n  url: string,\n  options: RequestInit = {},\n): Promise<Response<T>> {\n  const res = await fetch(url, options);\n  const response = await res.json();\n\n  return {\n    response: response as T,\n    status: res.status,\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}