{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "geoapify-provider",
  "title": "Geoapify Provider",
  "description": "Fetches location suggestions from Geoapify Places API. Requires a Geoapify API key. Provides detailed location data including city, country, and coordinates.",
  "files": [
    {
      "path": "src/lib/autocomplete/providers/geoapify.ts",
      "content": "import type {\n  LocationSuggestion,\n  ProviderConfig,\n} from \"@/components/ui/location-autocomplete\";\nimport { buildQueryString, fetcher } from \"@/lib/autocomplete/api\";\n\nconst BASE_URL = \"https://api.geoapify.com/v1/geocode/autocomplete\";\n\n/**\n * Options for the Geoapify Autocomplete API.\n */\nexport interface GeoapifyQueryOptions {\n  /**\n   * Your Geoapify API key.\n   * Required.\n   * Example: \"c3da27885e3573e09e550d044bc55e22\"\n   */\n  apiKey: string;\n\n  /**\n   * The address or part of the address to search for.\n   * Required.\n   * Example: \"Auts\"\n   */\n  text: string;\n\n  /**\n   * Location type to restrict results.\n   * Optional.\n   * Possible values:\n   * - 'country'\n   * - 'state'\n   * - 'city'\n   * - 'postcode'\n   * - 'street'\n   * - 'amenity'\n   * - 'locality'\n   *\n   * Example: 'locality'\n   */\n  type?:\n    | \"country\"\n    | \"state\"\n    | \"city\"\n    | \"postcode\"\n    | \"street\"\n    | \"amenity\"\n    | \"locality\";\n\n  /**\n   * Result language using 2-character ISO 639-1 code.\n   * Optional.\n   * Example: 'de'\n   */\n  lang?: string;\n\n  /**\n   * Filter the results by country, boundary, or circle.\n   * Optional.\n   * Format examples:\n   * - rectangle: \"rect:-122.569140,37.936672,-122.5324795,37.9588474\"\n   */\n  filter?: string;\n\n  /**\n   * Bias search results toward a specific location.\n   * Optional.\n   * Format examples:\n   * - proximity: \"proximity:-122.52985959,37.95335060\"\n   */\n  bias?: string;\n\n  /**\n   * Response format.\n   * Optional. Defaults to 'geojson'.\n   * Possible values: 'json', 'xml', 'geojson'\n   */\n  format?: \"json\" | \"xml\" | \"geojson\";\n}\n\n// Geoapify Autocomplete API types (FeatureCollection)\nexport interface GeoapifyAutocompleteResponse {\n  type: \"FeatureCollection\";\n  features: GeoapifyFeature[];\n  query?: {\n    text?: string;\n    parsed?: {\n      city?: string;\n      expected_type?: string;\n    };\n    categories?: string[];\n  };\n}\n\nexport interface GeoapifyFeature {\n  type: \"Feature\";\n  properties: GeoapifyProperties;\n  geometry: GeoapifyGeometry;\n  bbox?: [number, number, number, number];\n}\n\nexport interface GeoapifyProperties {\n  datasource?: GeoapifyDatasource;\n  // Common addressing fields returned by Geoapify\n  country?: string;\n  country_code?: string;\n  region?: string;\n  state?: string;\n  state_code?: string;\n  county?: string;\n  county_code?: string;\n  city?: string;\n  village?: string;\n  municipality?: string;\n  suburb?: string;\n  neighbourhood?: string;\n  postcode?: string;\n  iso3166_2?: string;\n  iso3166_2_sublevel?: string;\n  // Coordinates also appear in properties for convenience\n  lon?: number;\n  lat?: number;\n  // Result descriptors\n  name?: string;\n  result_type?: string; // e.g., 'city', 'state', 'postcode'\n  category?: string; // e.g., 'populated_place', 'administrative'\n  formatted?: string; // pre-formatted label\n  address_line1?: string;\n  address_line2?: string;\n  // Plus codes\n  plus_code?: string;\n  plus_code_short?: string;\n  // Timezone info\n  timezone?: GeoapifyTimezone;\n  // Ranking\n  rank?: GeoapifyRank;\n  // Identifier\n  place_id?: string;\n}\n\nexport interface GeoapifyDatasource {\n  sourcename?: string; // 'openstreetmap'\n  attribution?: string; // 'Â© OpenStreetMap contributors'\n  license?: string; // 'Open Database License'\n  url?: string;\n}\n\nexport interface GeoapifyTimezone {\n  name?: string; // e.g., 'Europe/Moscow'\n  name_alt?: string;\n  offset_STD?: string; // e.g., '+03:00'\n  offset_STD_seconds?: number;\n  offset_DST?: string;\n  offset_DST_seconds?: number;\n  abbreviation_STD?: string;\n  abbreviation_DST?: string;\n}\n\nexport interface GeoapifyRank {\n  importance?: number; // 0..1\n  confidence?: number; // 0..1\n  confidence_city_level?: number;\n  match_type?: string; // e.g., 'full_match'\n}\n\nexport interface GeoapifyGeometry {\n  type: \"Point\";\n  coordinates: [number, number]; // [lon, lat]\n}\n\nexport const normalizeGeoapifyResult = <T extends GeoapifyFeature>(\n  item: T,\n): LocationSuggestion<T> => ({\n  place_id: item.properties.place_id || Math.random().toString(),\n  display_name: item.properties.formatted || \"Unknown location\",\n  lat: String(item.properties.lat) || \"0\",\n  lon: String(item.properties.lon) || \"0\",\n  type: item.properties.result_type || \"unknown\",\n  importance: item.properties.rank?.importance || 0.5,\n  raw: item,\n});\n\nexport async function fetchGeoapifySuggestions(\n  query: string,\n  config: ProviderConfig,\n  options?: GeoapifyQueryOptions,\n): Promise<LocationSuggestion<GeoapifyFeature>[]> {\n  const apiKey = config.apiKey;\n  if (!apiKey) {\n    throw new Error(\"Geoapify requires an API key in config.apiKey\");\n  }\n\n  const params = buildQueryString({\n    ...(options || {}),\n    text: query,\n    apiKey: config.apiKey,\n  });\n\n  const url = `${config.baseUrl || BASE_URL}?${params}`;\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  return fetcher<GeoapifyAutocompleteResponse>(url, {\n    headers,\n  }).then(({ response }) => response.features.map(normalizeGeoapifyResult));\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/autocomplete/api.ts",
      "content": "export interface Response<T> {\n  response: T;\n  status: number;\n}\n\nexport const buildQueryString = (\n  params: Record<\n    string,\n    string | number | boolean | undefined | null | number[]\n  >,\n): string => {\n  return Object.entries(params)\n    .filter(\n      ([_, value]) => value !== undefined && value !== null && value !== \"\",\n    ) // skip empty\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`,\n    )\n    .join(\"&\");\n};\n\nexport async function fetcher<T>(\n  url: string,\n  options: RequestInit = {},\n): Promise<Response<T>> {\n  const res = await fetch(url, options);\n  const response = await res.json();\n\n  return {\n    response: response as T,\n    status: res.status,\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}