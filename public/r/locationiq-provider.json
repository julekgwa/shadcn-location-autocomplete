{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "locationiq-provider",
  "title": "LocationIQ Provider",
  "description": "Fetches location suggestions from LocationIQ API. Requires a LocationIQ API key. Returns place information with coordinates, display name, and structured address.",
  "files": [
    {
      "path": "src/lib/autocomplete/providers/locationiq.ts",
      "content": "import type {\n  LocationSuggestion,\n  ProviderConfig,\n} from \"@/components/ui/location-autocomplete\";\nimport { buildQueryString, fetcher } from \"@/lib/autocomplete/api\";\n\nconst BASE_URL = \"https://us1.locationiq.com/v1/search.php\";\n\n/**\n * Query options for the LocationIQ Autocomplete API.\n */\nexport interface LocationIQQueryOptions {\n  /**\n   * Maximum number of results to return.\n   * Optional. Default: 10. Allowed range: 1â€“20.\n   */\n  limit?: number;\n\n  /**\n   * Limit search to specific countries.\n   * Optional. Comma-separated list of ISO 3166-1 alpha-2 country codes (uppercase).\n   * Example: \"US,CA,GB\"\n   */\n  countrycodes?: string;\n\n  /**\n   * Normalize the city field if missing in the response.\n   * 0 = disable (default), 1 = enable normalization.\n   * If enabled, the next available element in the following order will be used as the city:\n   * city_district, locality, town, borough, municipality, village, hamlet, quarter, neighbourhood\n   */\n  normalizecity?: 0 | 1;\n\n  /**\n   * Preferred language for the search results.\n   * Optional. Default: 'en'.\n   * Only a single 2-character ISO 639-1 language code is supported.\n   * Supported: \"en\", \"cs\", \"nl\", \"fr\", \"de\", \"id\", \"it\", \"no\", \"pl\", \"es\", \"ru\", \"sv\", \"uk\"\n   */\n  \"accept-language\"?: string;\n}\n\n// LocationIQ Search API types\nexport type LocationIQResponse = LocationIQSearchResult[];\n\nexport interface LocationIQSearchResult {\n  place_id: string; // e.g., \"322169966452\"\n  osm_id?: string; // e.g., \"25503669\"\n  osm_type?: \"node\" | \"way\" | \"relation\" | string;\n  licence?: string; // attribution URL\n  lat: string; // stringified latitude\n  lon: string; // stringified longitude\n  boundingbox?: [string, string, string, string]; // [south, north, west, east]\n  class?: string; // e.g., 'place', 'amenity', 'leisure', 'tourism'\n  type?: string; // e.g., 'city', 'university', 'garden'\n  display_name: string;\n  display_place?: string;\n  display_address?: string;\n  address?: LocationIQAddress;\n}\n\nexport interface LocationIQAddress {\n  name?: string;\n  house_number?: string;\n  road?: string;\n  neighbourhood?: string;\n  suburb?: string;\n  city?: string;\n  town?: string;\n  village?: string;\n  county?: string;\n  state?: string;\n  state_district?: string;\n  postcode?: string;\n  country?: string;\n  country_code?: string; // ISO 3166-1 alpha-2 (e.g., 'za')\n}\n\nexport const normalizeLocationIQResult = <T extends LocationIQSearchResult>(\n  item: T,\n): LocationSuggestion<T> => ({\n  place_id:\n    item.place_id || item.osm_id?.toString() || Math.random().toString(),\n  display_name: item.display_name || \"Unknown location\",\n  lat: item.lat || \"0\",\n  lon: item.lon || \"0\",\n  type: item.type || item.class || \"unknown\",\n  importance: 0.5,\n  raw: item,\n});\n\nexport async function fetchLocationIQSuggestions(\n  query: string,\n  config: ProviderConfig,\n  options?: LocationIQQueryOptions,\n): Promise<LocationSuggestion<LocationIQSearchResult>[]> {\n  const apiKey = config.apiKey;\n  if (!apiKey) {\n    throw new Error(\"LocationIQ requires an API key in config.apiKey\");\n  }\n\n  const params = buildQueryString({\n    ...(options || {}),\n    key: config.apiKey,\n    q: query,\n    format: \"json\",\n  });\n\n  const url = `${config.baseUrl || BASE_URL}?${params}`;\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  return fetcher<LocationIQResponse>(url, {\n    headers,\n  }).then(({ response }) => response.map(normalizeLocationIQResult));\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/autocomplete/api.ts",
      "content": "export interface Response<T> {\n  response: T;\n  status: number;\n}\n\nexport const buildQueryString = (\n  params: Record<\n    string,\n    string | number | boolean | undefined | null | number[]\n  >,\n): string => {\n  return Object.entries(params)\n    .filter(\n      ([_, value]) => value !== undefined && value !== null && value !== \"\",\n    ) // skip empty\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`,\n    )\n    .join(\"&\");\n};\n\nexport async function fetcher<T>(\n  url: string,\n  options: RequestInit = {},\n): Promise<Response<T>> {\n  const res = await fetch(url, options);\n  const response = await res.json();\n\n  return {\n    response: response as T,\n    status: res.status,\n  };\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:lib"
}